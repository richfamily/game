--[[
    MinionManager.lua
    Fixed version that works with your existing MINION_BASIC_MODEL
    TYPE: ModuleScript (place in ReplicatedStorage.Modules)
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local MinionManager = {}
MinionManager.__index = MinionManager

-- Create a new MinionManager instance
function MinionManager.new()
	local self = setmetatable({}, MinionManager)

	-- Initialize properties
	self.ActiveMinions = {} -- Table to track active minions in the game

	return self
end

-- Generate a unique UUID for minions
function MinionManager:GenerateUUID()
	local template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
	return string.gsub(template, '[xy]', function(c)
		local v = (c == 'x') and math.random(0, 0xf) or math.random(8, 0xb)
		return string.format('%x', v)
	end)
end

-- Spawn a minion in the world
function MinionManager:SpawnMinion(minionData, player)
	print("Attempting to spawn minion: " .. minionData.ID .. " for player: " .. player.Name)

	-- Get the minion model
	local minionModel = self:GetMinionModel(minionData.ID, minionData.Variant)
	if not minionModel then
		warn("Failed to find model for minion: " .. minionData.ID)
		return self:CreateEmergencyMinion(minionData, player)
	end

	-- Clone the model
	local minion = minionModel:Clone()
	minion.Name = "Minion_" .. minionData.UUID

	-- Set up the minion properties
	self:SetupMinion(minion, minionData, player)

	-- Add to active minions
	self.ActiveMinions[minionData.UUID] = {
		Model = minion,
		Data = minionData,
		Player = player
	}

	print("Spawned minion: " .. minionData.ID .. " for player: " .. player.Name)
	return true
end

-- Get a minion model from ReplicatedStorage
function MinionManager:GetMinionModel(minionID, variant)
	-- Default to Normal variant if not specified
	variant = variant or "Normal"

	-- First, check in the standard path: ReplicatedStorage.Assets.Minions.Normal
	local assets = ReplicatedStorage:FindFirstChild("Assets")
	if assets then
		local minions = assets:FindFirstChild("Minions")
		if minions then
			local variantFolder = minions:FindFirstChild(variant)
			if variantFolder then
				local modelName = minionID .. "_MODEL"
				local model = variantFolder:FindFirstChild(modelName)
				if model then
					return model
				end
			end
		end
	end

	-- Second, search directly in ReplicatedStorage
	local directModel = ReplicatedStorage:FindFirstChild(minionID .. "_MODEL")
	if directModel then
		return directModel
	end

	-- As a fallback, look anywhere in ReplicatedStorage with FindFirstChild
	local model = ReplicatedStorage:FindFirstChild(minionID .. "_MODEL", true)
	if model then
		return model
	end

	-- If we still can't find it, create a simple placeholder model
	return self:CreateEmergencyMinion(minionData, player)
end

-- Setup a minion instance with the proper properties
function MinionManager:SetupMinion(minion, minionData, player)
	-- Get the player's character
	local character = player.Character
	if not character then return end

	-- Find appropriate parts
	local primaryPart = minion.PrimaryPart
	if not primaryPart then
		-- Try to find a part to use as primary part
		for _, part in pairs(minion:GetDescendants()) do
			if part:IsA("BasePart") then
				primaryPart = part
				minion.PrimaryPart = part
				break
			end
		end
	end

	if not primaryPart then
		warn("No primary part found for minion. Creating a new part.")
		local newPart = Instance.new("Part")
		newPart.Name = "MinionBody"
		newPart.Size = Vector3.new(1, 1, 1)
		newPart.Transparency = 1 -- Invisible part since it's just for following
		newPart.CanCollide = false
		newPart.Anchored = false
		newPart.Parent = minion
		primaryPart = newPart
		minion.PrimaryPart = newPart
	end

	-- Position the minion near the player
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if rootPart then
		-- Position a bit behind the player
		local offset = CFrame.new(0, 0, -5)
		minion:SetPrimaryPartCFrame(rootPart.CFrame * offset)
	end

	-- Create folders for organization
	local minionsFolder = workspace:FindFirstChild("Minions")
	if not minionsFolder then
		minionsFolder = Instance.new("Folder")
		minionsFolder.Name = "Minions"
		minionsFolder.Parent = workspace
	end

	local playerMinionsFolder = minionsFolder:FindFirstChild(player.Name)
	if not playerMinionsFolder then
		playerMinionsFolder = Instance.new("Folder")
		playerMinionsFolder.Name = player.Name
		playerMinionsFolder.Parent = minionsFolder
	end

	minion.Parent = playerMinionsFolder

	-- Make minion not collide with other minions or players
	for _, part in ipairs(minion:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = false
			part.Anchored = false
		end
	end

	-- Add nametag if it doesn't exist
	if not minion:FindFirstChild("NameTag") and primaryPart then
		local billboardGui = Instance.new("BillboardGui")
		billboardGui.Name = "NameTag"
		billboardGui.Size = UDim2.new(0, 100, 0, 40)
		billboardGui.StudsOffset = Vector3.new(0, 2, 0)
		billboardGui.Adornee = primaryPart
		billboardGui.Parent = minion

		local nameLabel = Instance.new("TextLabel")
		nameLabel.Name = "NameLabel"
		nameLabel.Size = UDim2.new(1, 0, 1, 0)
		nameLabel.BackgroundTransparency = 1
		nameLabel.TextColor3 = Color3.new(1, 1, 1)
		nameLabel.TextStrokeTransparency = 0
		nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
		nameLabel.Font = Enum.Font.GothamBold
		nameLabel.TextSize = 14
		nameLabel.Text = "Basic Minion"
		nameLabel.Parent = billboardGui
	end

	-- Set up follow behavior with WeldConstraint for simplicity and reliability
	self:SetupFollowBehavior(minion, player)
end

-- Set up reliable follow behavior
function MinionManager:SetupFollowBehavior(minion, player)
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return end

	local rootPart = character.HumanoidRootPart
	local primaryPart = minion.PrimaryPart

	if not primaryPart then
		warn("Cannot setup follow behavior - minion has no primary part")
		return
	end

	-- First remove any existing constraints
	for _, child in pairs(minion:GetChildren()) do
		if child:IsA("WeldConstraint") or child:IsA("AlignPosition") then
			child:Destroy()
		end
	end

	-- Create the weld constraint
	local weld = Instance.new("WeldConstraint")
	weld.Name = "FollowWeld"
	weld.Part0 = rootPart
	weld.Part1 = primaryPart
	weld.Parent = minion

	-- Position the minion behind the player
	minion:SetPrimaryPartCFrame(rootPart.CFrame * CFrame.new(0, 0, -5))

	print("Set up follow behavior for minion: " .. minion.Name)
end

-- Create emergency minion when nothing else works
function MinionManager:CreateEmergencyMinion(minionData, player)
	print("Creating emergency minion for player: " .. player.Name)

	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		warn("Player character not found for emergency minion creation")
		return false
	end

	-- Create a model
	local model = Instance.new("Model")
	model.Name = "EmergencyMinion_" .. minionData.UUID

	-- Create the body part
	local body = Instance.new("Part")
	body.Name = "Body"
	body.Shape = Enum.PartType.Ball
	body.Size = Vector3.new(2, 2, 2) * 0.5
	body.BrickColor = BrickColor.new("Bright blue")
	body.Material = Enum.Material.Neon
	body.CanCollide = false
	body.Anchored = false
	body.Parent = model

	model.PrimaryPart = body

	-- Create a billboard GUI for the name
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Name = "NameTag"
	billboardGui.Size = UDim2.new(0, 100, 0, 40)
	billboardGui.StudsOffset = Vector3.new(0, 1, 0)
	billboardGui.Adornee = body
	billboardGui.Parent = body

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "NameLabel"
	nameLabel.Size = UDim2.new(1, 0, 1, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.TextColor3 = Color3.new(1, 1, 1)
	nameLabel.TextStrokeTransparency = 0
	nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextSize = 14
	nameLabel.Text = "Basic Minion"
	nameLabel.Parent = billboardGui

	-- Create folder structure if needed
	local minionsFolder = workspace:FindFirstChild("Minions")
	if not minionsFolder then
		minionsFolder = Instance.new("Folder")
		minionsFolder.Name = "Minions"
		minionsFolder.Parent = workspace
	end

	local playerMinionsFolder = minionsFolder:FindFirstChild(player.Name)
	if not playerMinionsFolder then
		playerMinionsFolder = Instance.new("Folder")
		playerMinionsFolder.Name = player.Name
		playerMinionsFolder.Parent = minionsFolder
	end

	-- Positioning
	local rootPart = character.HumanoidRootPart
	body.CFrame = rootPart.CFrame * CFrame.new(0, 0, -5)

	model.Parent = playerMinionsFolder

	-- Create a weld constraint
	local weld = Instance.new("WeldConstraint")
	weld.Name = "FollowWeld"
	weld.Part0 = rootPart
	weld.Part1 = body
	weld.Parent = model

	-- Track it in active minions
	self.ActiveMinions[minionData.UUID] = {
		Model = model,
		Data = minionData,
		Player = player
	}

	print("Created emergency minion for player: " .. player.Name)
	return true
end

-- Despawn a minion by UUID
function MinionManager:DespawnMinion(minionUUID)
	local minionData = self.ActiveMinions[minionUUID]
	if not minionData then
		warn("Minion not found with UUID: " .. minionUUID)
		return false
	end

	-- Destroy the model
	if minionData.Model then
		minionData.Model:Destroy()
	end

	-- Remove from active minions
	self.ActiveMinions[minionUUID] = nil

	return true
end

-- Despawn all minions for a player
function MinionManager:DespawnPlayerMinions(player)
	local minionsToRemove = {}

	-- Find all minions belonging to the player
	for uuid, minionData in pairs(self.ActiveMinions) do
		if minionData.Player == player then
			table.insert(minionsToRemove, uuid)
		end
	end

	-- Despawn each minion
	for _, uuid in ipairs(minionsToRemove) do
		self:DespawnMinion(uuid)
	end

	return #minionsToRemove > 0
end

return MinionManager.new() -- Return an instance instead of the class
